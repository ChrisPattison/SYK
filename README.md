# SYK

Research code for investigating the ``monoparametric'' ensemble for SYK and GUE ensembles
## Singularity .def file configuration

### GPUs: number of GPUs

Magma uses MAGMA_NUM_GPUS to determine the number of GPUs to use
This can changed at runtime by setting SINGULARITYENV_MAGMA_NUM_GPUS in the host environment before executing the container

    SINGULARITYENV_MAGMA_NUM_GPUS=2 singularity exec ...

if not explicitly set, the image will try to run nvidia-smi to determine how many GPUs are available.  
If it cannot run the command successfully, the build will set MAGMA_NUM_GPUS to zero [what is the result]

### GPUs: Consumer vs. professional

Consumer GPUs (e.g. Titan which the SITP machine has) have extremely limited FP64 support.
For testing purposes we can use FP32 on these GPUs, but we expect FP64 to be necessary for data collection runs.

In syk.def uncomment:

    -DDIAG_SINGLE_PRECISION=ON

When built with single precision it will print a warning on startup:
WARNING: Built with FP32 diagonalization

## Execution command line options

Note: These programs are run in the singularity container with `singularity exec`

### Create Hamiltinians

    gen_ham <output_file> <num_hamiltonians> <ensemble [syk/gue/goe]> <size>

This generates samples from the full ensemble to input to mixer

output_file: The file written to for input to mixer
num_hamiltonians: How many samples from the full ensemble. If num_hamiltonians = n the "single parameter" ensemble is
alpha_1 H_1 + alpha_2 H_2 + .... + alpha_n H_n
where alpha_2 to alpha_n is from a gaussian of width distr_width and alpha_1 is changed to preserve normalization

ensemble: syk gives only the even parity sector
size: gue/goe is Hilbert space dimension, syk is # of Majorana fermions.

### Diagonalize

    mixer <input_file> <output_file> <samples> <distr_width> [checkpoint_file] [checkpoint_period (s)]

input_file: file generated by gen_ham
output_file: file output
samples: Number of samples from the single parameter ensemble to sample and diagonalize
distr_width: see num_hamiltonians for gen_ham
checkpoint_file: optional, if supplied it will write to the checkpoint file every checkpoint_period seconds. 
If already present it will compare a hash of the input_file against what checkpoint_file used.

--nv turns on the CUDA support for singularity. This is necessary to run the GPU diagonalization. There's also some other diagonalization (CPU and GPU) implementations that you can switch to in the source if you want although we do not automatically fall back to them.
The 4096 in the output file name isn't special, but the plotting script uses it to get a nice name for the legend.
The last two arguments are optional: If they are supplied, it will checkpoint after the supplied number of seconds have elapsed. If you restart, it will first check if the checkpoint is present and load from it if so. 

I had originally intended to allow checkpointing in the middle of the diagonalization routine, but that requires some surgery in the diagonalization libraries that I haven't committed to yet.

### Plot

Example:

    singularity exec syk.sif python src/plot/plot_spectral.py output.4096.bin

## Building the singularity container

### On a Mac using Vagrant

1. `vagrant init singularityware/singularity-2.4`
1. `vagrant up`
1. `vagrant ssh`

1. `git clone <SYK repo>`
1. `cd  repo`
1. `make` [ Will make base.sif and syk.sif ]

